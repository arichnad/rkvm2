syntax = "proto3";

package dtx.proto;
option java_multiple_files = true;
option java_outer_classname = "DefendTexProto";


import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

/**************************************************************

 Model structs and enums

 **************************************************************/

/**
 * Because we can support multiple proxies and ids do not have
 * to be unique across them, this represents an id that is unique
 * by combining the proxy id and the sys id.
 */
message SysId {
  /**
   * the id of the proxy
   */
  string proxyId = 1;
  /**
   * A u8 id for the system
   */
  uint32 sysId = 2;
}

/**
 * Type of gps fix
 */
enum GpsFixType {
  /**
   * No GPS connected
   */
  NoGps = 0;
  /**
   * No position information, GPS is connected
   */
  NoFix = 1;
  /**
   * 2D position
   */
  GpsFixType2dFix = 2;
  /**
   * 3D position
   */
  GpsFixType3dFix = 3;
  /**
   * DGPS/SBAS aided 3D position
   */
  Dgps = 4;
  /**
   * RTK float, 3D position
   */
  RtkFloat = 5;
  /**
   * RTK Fixed, 3D position
   */
  RtkFixed = 6;
  /**
   * Static fixed, typically used for base stations
   */
  Static = 7;
  /**
   * PPP, 3D position.
   */
  Ppp = 8;
}

/**
 * A WGS84 location
 */
message GeoPoint {
  /**
   * The WGS84 longitude in decimal degrees
   */
  float latitude = 1;
  /**
   * The WGS84 longitude in decimal degrees
   */
  float longitude = 2;
  /**
   * The altitude (MSL)
   */
  float altitude = 3;
}

/**
 * A geo location reading
 */
message GeoReading {
  /**
   * The time that this reading was taken in
   * milliseconds since unix epoch
   */
  google.protobuf.Timestamp time = 1;
  /**
   * The WGS84 point
   */
  GeoPoint point = 2;
  /**
   * bearing in degrees from true north (todo: this might be mag)
   */
  float bearing = 3;
  /**
   * speed in m/s
   */
  float speed = 4;
  /**
   * GPS HDOP horizontal dilution of position (unitless)
   */
  float hdop = 5;
  /**
   * GPS VDOP vertical dilution of position (unitless)
   */
  float vdop = 6;
  /**
   * Fix type
   */
  GpsFixType fixType = 7;
  /**
   * Num visible satellites
   */
  uint32 visibleSatelliteCount = 8;
}

message Battery {
  uint32 voltage = 1;
  uint32 current = 2;
  int32 remaining = 3;
}

/**
 * Tube state info
 */
enum TubeState {
  /**
   * The tube is not loaded
   */
  NotLoaded = 0;
  /**
   * The tube is loaded.  A sys_id should be set in the tube struct
   */
  Loaded = 1;
  /**
   * The tube is firing
   */
  Launching = 2;
  /**
   * The launch failed.  This is a bad state and we shouldn't go back to LOADED
   * unless something explicit happens.  We still need to decide what that explicit
   * thing is.
   */
  LaunchFailed = 3;
  /**
   * The cap is charging
   */
  Charging = 4;
}

/**
 * A launcher
 */
message Launcher {
  /**
   * The set of tubes
   */
  repeated Tube tube = 1;
  /**
   * The geo location
   */
  GeoReading location = 2;
  /**
   * The name of the launcher
   */
  string name = 3;
  /**
   * The charge state
   */
  Battery battery = 4;
  /**
   * The configured safe radius around the launcher
   */
  uint32 safeDistance = 5;
  /**
   * Is the airspace around the launcher clear?
   */
  bool airspaceClear = 6;
}

/**
 * A tube
 */
message Tube {
  /**
   * The ID
   */
  int32 id = 1;
  /**
   * The state
   */
  TubeState state = 2;
  /**
   * The sys id of the drone that's loaded into the tube if the tube is loaded.
   */
  SysId sysId = 3;
  /**
   * The cap charge value
   */
  uint32 charge = 4;
}

enum Severity {
  /**
   * Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: <http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.>
   * System is unusable. This is a "panic" condition.
   */
  Emergency = 0;
  /**
   * Action should be taken immediately. Indicates error in non-critical systems.
   */
  Alert = 1;
  /**
   * Action must be taken immediately. Indicates failure in a primary system.
   */
  Critical = 2;
  /**
   * Indicates an error in secondary/redundant systems.
   */
  Error = 3;
  /**
   * Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning.
   */
  Warning = 4;
  /**
   * An unusual event has occurred, though not an error condition. This should be investigated for the root cause.
   */
  Notice = 5;
  /**
   * Normal operational messages. Useful for logging. No action is required for these messages.
   */
  Info = 6;
  /**
   * Useful non-operational messages that can assist in debugging. These should not occur during normal operation.
   */
  Debug = 7;
}

enum DroneState {
  /**
   * Uninitialized system, state is unknown.
   */
  Uninit = 0;
  /**
   * System is booting up.
   */
  Boot = 1;
  /**
   * System is calibrating and not flight-ready.
   */
  Calibrating = 2;
  /**
   * System is grounded and on standby. It can be launched any time.
   */
  Standby = 3;
  /**
   * System is active and might be already airborne. Motors are engaged.
   */
  Active = 4;
  /**
   * System is in a non-normal flight mode. It can however still navigate.
   */
  CriticalState = 5;
  /**
   * System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down.
   */
  EmergencyState = 6;
  /**
   * System just initialized its power-down sequence, will shut down now.
   */
  Poweroff = 7;
  /**
   * System is terminating itself.
   */
  FlightTermination = 8;
}

enum AutopilotMode {
  /**
   * manual airframe angle with manual throttle
   */
  STABILIZE = 0;
  /**
   * manual body-frame angular rate with manual throttle
   */
  ACRO = 1;
  /**
   * manual airframe angle with automatic throttle
   */
  ALT_HOLD = 2;
  /**
   * fully automatic waypoint control using mission commands
   */
  AUTO = 3;
  /**
   * fully automatic fly to coordinate or fly at velocity/direction using GCS immediate commands
   */
  GUIDED = 4;
  /**
   * automatic horizontal acceleration with automatic throttle
   */
  LOITER = 5;
  /**
   * automatic return to launching point
   */
  RTL = 6;
  /**
   * automatic circular flight with automatic throttle
   */
  CIRCLE = 7;
  /**
   * automatic landing with horizontal position control
   */
  LAND = 9;
  /**
   * semi-autonomous position, yaw and throttle control
   */
  DRIFT = 11;
  /**
   * manual earth-frame angular rate control with manual throttle
   */
  SPORT = 13;
  /**
   * automatically flip the vehicle on the roll axis
   */
  FLIP = 14;
  /**
   * automatically tune the vehicle's roll and pitch gains
   */
  AUTOTUNE = 15;
  /**
   * automatic position hold with manual override, with automatic throttle
   */
  POSHOLD = 16;
  /**
   * full-brake using inertial/GPS system, no pilot input
   */
  BRAKE = 17;
  /**
   * throw to launch mode using inertial/GPS system, no pilot input
   */
  THROW = 18;
  /**
   * automatic avoidance of obstacles in the macro scale - e.g. full-sized aircraft
   */
  AVOID_ADSB = 19;
  /**
   *  guided mode but only accepts attitude and altitude
   */
  GUIDED_NOGPS = 20;
  /**
   * SMART_RTL returns to home by retracing its steps
   */
  SMART_RTL = 21;
  /**
   * FLOWHOLD holds position with optical flow without rangefinder
   */
  FLOWHOLD = 22;
  /**
   * follow attempts to follow another vehicle or ground station
   */
  FOLLOW = 23;
  /**
   * ZIGZAG mode is able to fly in a zigzag manner with predefined point A and point B
   */
  ZIGZAG = 24;
  /**
   * System ID mode produces automated system identification signals in the controllers
   */
  SYSTEMID = 25;
  /**
   * Autonomous autorotation
   */
  AUTOROTATE = 26;
}

message DroneStatusMessage {
  /**
   * The timestamp for the message
   */
  google.protobuf.Timestamp time = 1;
  /**
   * The message severity
   */
  Severity severity = 2;
  /**
   * The message text
   */
  string text = 3;
}

/**
 * Drone state info
 */
message DroneStatus {
  /**
   * The current state (per the drone)
   */
  DroneState state = 1;
  /**
   * The last status message
   */
  DroneStatusMessage message = 2;
  /**
   * current autopilot mode
   */
  AutopilotMode autopilotMode = 3;
}

/**
 * Drone mode info.  This is kind of a super-set of base mode and
 * auto pilot mode.  We don't want to expose user's to this because
 * it's pretty confusing.  The goal is to expose high-level modes
 * and, based on context, achieve them using the correct base and
 * auto-pilot modes in software.
 */
enum DroneMode {
  /**
   * We haven't heard from the drone yet
   */
  None = 0;
  /**
   * The drone is awaiting mode changes.  The drone will not fly in this state
   */
  StandBy = 1;
  /**
   * The drone is arming
   */
  Arming = 2;
  /**
   * The drone is ready to fly based on context.  If it's loaded into a barrel
   * this means that the drone is in throw mode and armed.
   */
  ReadyToFly = 3;
  /**
   * The drone is flying
   */
  Flying = 4;
  /**
   * The drone is landing
   */
  Landing = 5;
  /**
   * The drone is disarming
   */
  Disarming = 6;
}

/**
 * Allows us to force the payload into a state
 * or to use internal state (toggle)
 */
enum FirePayloadOption {
  /**
   * Toggle based on internal state
   */
  ToggleRelay  = 0;
  /**
   * Force enable
   */
  EnableRelay  = 1;
  /**
   * Force disable
   */
  DisableRelay = 2;
}

/**
 * An available drone connection
 */
message DroneConnection {
  /**
   * The sys id of the drone that's being connected
   */
  SysId sysId = 1;
  /**
   * Mavlink uri for the drone
   */
  string uri = 2;
}

message GotoTask {
  /**
   * The location of the target
   */
  GeoPoint location = 1;
}

message LoiterTask {
  /**
   * The amount of time to loiter in ms
   */
  uint64 duration = 1;
  /**
   * The time at which to finish loitering
   */
  google.protobuf.Timestamp time = 2;
  /**
   * The base time for time
   */
  google.protobuf.Timestamp baseTime = 3;
  /**
   * Rather than the duration or time being relative
   * to the last waypoint, the duration or time should
   * be relative to the mission upload time.  This
   * allows us to build gates for synchronized flying.
   */
  bool relativeToMissionUpload = 4;
}

message RTLTask {
  /**
   * The location of the launch or unset
   */
  GeoPoint location = 1;
}

message FirePayloadTask {
  /**
   * Rather than use the internal controller state, use this to trigger the payload
   */
  FirePayloadOption option = 1;
}

message StartMissionTask {
}

message TakeOffTask {
  /**
   * The altitude (MSL)
   */
  float altitude = 1;
}

message LandTask {
}

/**
 * Drone task
 */
message Task {
  oneof task_type {
    RTLTask rtl = 1;
    GotoTask goto = 2;
    LoiterTask loiter = 3;
    FirePayloadTask firePayload = 4;
    StartMissionTask startMission = 5;
    TakeOffTask takeOff = 6;
    LandTask land = 7;
  }
}

enum TaskState {
  /**
   * Command is valid (is supported and has valid parameters), and was executed.
   */
  Accepted = 0;
  /**
   * Command is valid, but cannot be executed at this time. This is used to indicate a problem that should be fixed just by waiting (e.g. a state machine is busy, can't arm because have not got GPS lock, etc.). Retrying later should work.
   */
  TemporarilyRejected = 1;
  /**
   * Command is invalid (is supported but has invalid parameters). Retrying same command and parameters will not work.
   */
  Denied = 2;
  /**
   * Command is not supported (unknown).
   */
  Unsupported = 3;
  /**
   * Command is valid, but execution has failed. This is used to indicate any non-temporary or unexpected problem, i.e. any problem that must be fixed before the command can succeed/be retried. For example, attempting to write a file when out of memory, attempting to arm when sensors are not calibrated, etc.
   */
  Failed = 4;
  /**
   * Command is valid and is being executed. This will be followed by further progress updates, i.e. the component may send further COMMAND_ACK messages with result MAV_RESULT_IN_PROGRESS (at a rate decided by the implementation), and must terminate by sending a COMMAND_ACK message with final result of the operation. The COMMAND_ACK.progress field can be used to indicate the progress of the operation.
   */
  InProgress = 5;
  /**
   * Command has been cancelled (as a result of receiving a COMMAND_CANCEL message).
   */
  Cancelled = 6;
  /**
   * Awaiting ack
   */
  PendingAck = 7;
  /**
   * Awaiting fix before command can be executed
   */
  PendingFix = 8;
  /**
   * Complete!
   */
  Complete = 9;
}

/**
 * Generic progress
 */
message Progress {
  /**
   * The current progress
   */
  uint64 progress = 1;
  /**
   * The max progress (0 for indeterminate, set to progress for completion)
   */
  uint64 max = 2;
}

/**
 * Drone mission
 */
message Mission {
  /**
   * The mission tasks
   */
  repeated Task tasks = 1;
  /**
   * The source system of the mission
   */
  string sourceId = 2;
  /**
   * A unique id for the mission
   */
  string id = 3;
}

/**
 * The mission state
 */
message MissionState {
  /**
   * The currently executing task id in the mission
   */
  uint32 taskId = 1;
  /**
   * The current state of the task
   */
  TaskState taskState = 2;
  /**
   * Sync progress
   */
  Progress syncProgress = 3;
}

message CameraPayload {
  /**
   * An rtsp uri string
   */
  string uri = 1;
  /**
   * The camera orientation.  A camera mounted upside-down will have a 180 degree orientation
   */
  float orientation = 2;
}

message LightAndSoundPayload {
}

message DronePayload {
  oneof drone_payload_type {
    CameraPayload camera = 1;
    LightAndSoundPayload lightAndSound = 2;
  }
}

/**
 * An available drone full info
 */
message Drone {
  /**
   * The sys id of the drone
   */
  SysId sysId = 1;
  /**
   * Mavlink uri for the drone
   */
  string uri = 2;
  /**
   * The state
   */
  DroneStatus status = 3;
  /**
   * The current mode
   */
  DroneMode mode = 10;
  /**
   * The most recent location
   */
  GeoReading location = 4;
  /**
   * The assigned mission
   */
  Mission mission = 5;
  /**
   * If a mission is executing, the mission state
   */
  MissionState missionState = 6;
  /**
   * Different kinds of payloads
   */
  DronePayload payload = 7;
  /**
   * Last time we heard from this drone
   */
  google.protobuf.Timestamp lastHeardFrom = 8;
  /**
   * The state of the battery
   */
  Battery battery = 9;
  /**
   * The RTL location
   */
  GeoPoint rtlLocation = 11;
}

/**************************************************************

 Request/Response/Event payloads

 **************************************************************/

/**
 * Launcher request details
 */
message LauncherRequestType {
  oneof launcher_request_type {
    /**
     * Launch some things from a tube
     */
    Launch launch = 1;
    /**
     * Load a drone into a tube
     */
    Load load = 2;
    /**
     * Update launcher info
     */
    Launcher updateLauncher = 3;
  }
}

/**
 * A request to the launcher
 */
message LauncherRequest {
  /**
   * Request details
   */
  LauncherRequestType details = 1;
}

/**
 * Launcher response.  Right now there are no launch details
 */
message LauncherResponse {
}

/**
 * Launch request
 */
message Launch {
  /**
   * The tube(s) that should be launched
   */
  repeated int32 tubeId = 1;
  /**
   * cancel the launch
   */
  bool cancel = 2;
  /**
   * force the launch.  This skips the airspace check.
   */
  bool force = 3;
}


/**
 * Load request.  Leaving sys id default will unload the tube
 */
message Load {
  /**
   * The tube id that should be loaded/unloaded
   */
  int32 tubeId = 1;
  /**
   * The sys id that should be loaded into the tube or unset to unload the tube
   */
  SysId sysId = 2;
}

/**
 * Launcher state event is fired when launcher state changes
 */
message LauncherStateEvent {
  /**
   * The set of tubes that changed
   */
  Launcher launcher = 1;
}

/**
 * Request to connect a mav proxy to the drone and start sending it's 
 * messages to mqtt.
 */
message DroneConnectRequest {
  /**
   * Drone to connect to
   */
  DroneConnection drone = 1;
}

/**
 * Request to disconnect a mav proxy from a drone.
 */
message DroneDisconnectRequest {
  /**
   * Drone to disconnect from
   */
  DroneConnection drone = 1;
}

/**
 * Response to a DroneConnectRequest
 */
message DroneConnectResponse {
}

/**
 * Response to a DroneDisConnectRequest
 */
message DroneDisconnectResponse {
}

/**
 * Drone request details
 */
message DroneRequestType {
  oneof drone_request_type {
    /**
     * Tell the drone to do a task
     */
    Task task = 1;
    /**
     * Tell the drone to go into this mode
     */
    DroneMode setMode = 2;
    /**
     * The mission
     */
    Mission setMission = 3;
    /**
     * The rtl location
     */
    GeoPoint setRtlLocation = 4;
    /**
     * Update the drone with this info
     */
    Drone updateDrone = 5;
    /**
     * Delete the drone
     */
    google.protobuf.Empty deleteDrone = 6;
    /**
     * Get the drone
     */
    google.protobuf.Empty getDrone = 7;
    /**
     * Clear the drone's current mission
     */
    google.protobuf.Empty clearMission = 8;
    /**
     * Clear the drone's current mission
     */
    google.protobuf.Empty syncMission = 9;
  }
}

/**
 * Request to tell a drone to do something
 */
message DroneRequest {
  /**
   * The drone
   */
  SysId sysId = 1;
  /**
   * The details
   */
  DroneRequestType details = 2;
}

message DroneResponse {
  /**
   * Drone state after the request
   */
  Drone drone = 1;
}

/**
 * Event indicating a proxy is running for a drone.
 */
message DroneConnectEvent {
  /**
   * Drone that was connected
   */
  DroneConnection drone = 1;
}

/**
 * Event indicating a proxy is no longer running for a drone.
 */
message DroneDisconnectEvent {
  /**
   * Drone that was disconnected
   */
  DroneConnection drone = 1;
}

/**
 * Drone state is updated periodically
 */
message DroneStateEvent {
  /**
   * The set of drones that changed
   */
  repeated Drone drone = 1;
}

/**************************************************************

 Messaging structs

 **************************************************************/

/**
 * A message.  This is the envelope inside of which data is transmitted.
 * There are lots of benefits to structuring messages this way.  This allows
 * for generic handling of base messaging features and ensures DRY.  This
 * also allows simple serialization and deserialization of streams of messages.
 * If _everything_ is a message we always know what to read.
 */
message Message {
  /**
   * Message header
   */
  Header header = 1;
  /**
   * Message data
   */
  Payload payload = 2;
}

/**
 * A message header.  This contains all information about identification and
 * direction of messages needed for service to properly and generically support
 * Event/Request/Response comms.
 */
message Header {
  /**
   * A unique id for a message.  This is required for Request messages as it
   * is used for response correlation.  It is optional for all other types of
   * messages but is nice for debugging.
   */
  string id = 1;
  /**
   * An identifier for the sending service/entity.  This is required for Request messages
   * as it is used for response correlation.  At some point this should be auth'd.
   */
  string fromId = 2;
  /**
   * An identifier for the receiving entity.  This is needed for direct requests and events.
   * If a request is for "whoever can deal with it", this may be left unset.
   */
  string toId = 3;
  /**
   * Send timestamp for the message.  Required for messages that have QoS requirements.
   */
  google.protobuf.Timestamp time = 4;

  /**
   * Specific header information
   */
  oneof header_type {
    EventHeader eventHeader = 10;
    RequestHeader requestHeader = 11;
    ResponseHeader responseHeader = 12;
  }
}

/**
 * Types of message payloads supported.  There's really 2 ways to do this.  This way,
 * which is generally cleaner and simpler to use and should be preferred given the types
 * of payloads are fairly constant.  The other way is to use protobuf's Any type which
 * is way more generic but way more complicated.
 */
message Payload {
  oneof payload_type {

    // launcher controller requests/events
    LauncherRequest launcherRequest = 1;
    LauncherResponse launcherResponse = 2;
    LauncherStateEvent launcherStateEvent = 3;

    // proxy requests/events
    DroneConnectRequest droneConnectRequest = 4;
    DroneDisconnectRequest droneDisconnectRequest = 5;
    DroneConnectResponse droneConnectResponse = 6;
    DroneDisconnectResponse droneDisconnectResponse = 7;
    DroneConnectEvent droneConnectEvent = 8;
    DroneDisconnectEvent droneDisconnectEvent = 9;

    // drone controller requests/events
    DroneRequest droneRequest = 10;
    DroneResponse droneResponse = 11;
    DroneStateEvent droneStateEvent = 12;

    google.protobuf.Empty empty = 13;
  }
}

/**
 * Response codes.  These should be expanded to include more specific things
 */
enum ResponseCode {
  /**
   * The request was successful
   */
  OK = 0;
  /**
   * The request failed generically
   */
  ERROR = 1;
  /**
   * The response is an update.  This may be used to implement long running requests.
   */
  UPDATE = 2;
}

/**
 * Event header data.  It's possible that this could contain a sequence number
 * so that clients could react or nak generally.  Doesn't really seem necessary
 * right now.
 */
message EventHeader {
}

/**
 * Request header data
 */
message RequestHeader {
  /**
   * Set to true to cancel the request described in the header
   */
  bool cancel = 1;
}

/**
 * Response header can generically describe request success and failure.  This
 * also contains the requestId for request correlation.  The requestId will match
 * the id in the Header of the request message.  Any response details may be added
 * as a specific payload_type.
 */
message ResponseHeader {
  /**
   * Response code
   */
  ResponseCode code = 1;
  /**
   * An optional message
   */
  string message = 2;
  /**
   * The request id.  This is required
   */
  string requestId = 3;
}
